<!DOCTYPE html>
<html lang='en'>
  <head>
    <title>Events</title>
    <style>
      body {
        padding: 2em;
        font-family: Arial; }
      
      div {
        border: 0;
        box-sizing: border-box;
        cursor: pointer; }
      
      ul {
        list-style-type: none;
        padding: 0;
        margin: 0; }
      
      div#outer {
        float: left;
        overflow: auto; }
      
      table#controls, section#sidebar {
        float: left;
        margin-left: 2em; }
      
      table#controls {
        float: left;
        width: 200px;
        vertical-align: top; }
      
      section#sidebar {
        width: 400px; }
        section#sidebar #instructions {
          border: 1px solid silver;
          margin: 5px 0; }
          section#sidebar #instructions li {
            border: 1px solid black;
            display: inline-block; }
          section#sidebar #instructions span {
            display: inline-block;
            padding: 5px;
            line-height: 16px;
            text-align: center;
            vertical-align: middle; }
          section#sidebar #instructions .key {
            width: 16px;
            height: 16px;
            background: silver; }
      
      table#controls {
        margin-bottom: 1em;
        font-size: 12px; }
        table#controls thead {
          cursor: pointer; }
        table#controls thead td {
          font-weight: bold; }
        table#controls td {
          padding: 3px; }
        table#controls.hidden tr.control {
          display: none; }
        table#controls td:first-child + td + td, table#controls td:last-child {
          text-align: center;
          width: 16px; }
      
      table#logger .phaseIcon {
        text-align: center; }
      table#logger tr {
        border: 2px solid black;
        background: white; }
        table#logger tr td {
          background: white; }
      table#logger thead td {
        font-weight: bold;
        font-family: Monospace;
        font-size: 16px; }
      
      table {
        width: 100%;
        border-collapse: collapse;
        vertical-align: top;
        background: white; }
        table tr.animating td {
          background-color: inherit; }
        table thead tr {
          background: #efefef; }
        table td {
          padding: 5px;
          border: 1px solid black; }
      
      table#logger tr, table#controls tr {
        border: 1px solid black;
        background: white; }
      
      div.target nope {
        border-width: 20px 20px 0 20px;
        border-style: ridge; }
      
      #outer {
        display: inline-block;
        width: 500px;
        height: 300px; }
        #outer #inner {
          width: 75%;
          height: 75%; }
          #outer #inner #core {
            width: 75%;
            height: 75%; }
      
      #outer {
        position: relative; }
        #outer #inner {
          position: absolute;
          left: 12.5%;
          bottom: 0; }
          #outer #inner #core {
            position: absolute;
            left: 12.5%;
            bottom: 0; }
    </style>
  </head>
  <body class='mode-live'>
    <div id='outer'>
      <div id='inner'>
        <div id='core'></div>
      </div>
    </div>
    <section id='sidebar'>
      <section id='instructions'>
        <ul>
          <li id='clear'>
            <span class='key'>c</span>
            <span class='usage'>clear</span>
          </li>
          <li id='queueMode'>
            <span class='key'>q</span>
            <span class='usage'>mode</span>
          </li>
          <li id='play'>
            <span class='key'>p</span>
            <span class='usage'>play</span>
          </li>
          <li id='speed'>
            <span class='key'>+/-</span>
            <span class='usage'>speed</span>
          </li>
        </ul>
      </section>
      <section id='meta'>
        <strong>mode:</strong>
        <span class='queueMode'>live</span>
        <strong>speed:</strong>
        <span class='speed'>10</span>
      </section>
      <table id='logger'>
        <thead>
          <tr>
            <td class='phase' colspan='2'>phase</td>
            <td class='event'>event</td>
            <td class='currentTarget'>handled by</td>
            <td class='target'>target</td>
          </tr>
        </thead>
      </table>
    </section>
    <table id='controls'>
      <thead>
        <tr>
          <td class='element'>element</td>
          <td class='event'>event</td>
          <td class='capture' title='capture'>⬇</td>
          <td class='bubble' title='bubble'>⬆</td>
        </tr>
      </thead>
      <tr class='click control'>
        <td class='outer'>outer</td>
        <td>click</td>
        <td class='capture'>
          <input data-element='outer' data-event='click' data-phase='capture' type='checkbox'>
        </td>
        <td class='bubble'>
          <input data-element='outer' data-event='click' data-phase='bubble' type='checkbox'>
        </td>
      </tr>
      <tr class='control mouseover'>
        <td class='outer'>outer</td>
        <td>mouseover</td>
        <td class='capture'>
          <input data-element='outer' data-event='mouseover' data-phase='capture' type='checkbox'>
        </td>
        <td class='bubble'>
          <input data-element='outer' data-event='mouseover' data-phase='bubble' type='checkbox'>
        </td>
      </tr>
      <tr class='click control'>
        <td class='inner'>inner</td>
        <td>click</td>
        <td class='capture'>
          <input data-element='inner' data-event='click' data-phase='capture' type='checkbox'>
        </td>
        <td class='bubble'>
          <input data-element='inner' data-event='click' data-phase='bubble' type='checkbox'>
        </td>
      </tr>
      <tr class='control mouseover'>
        <td class='inner'>inner</td>
        <td>mouseover</td>
        <td class='capture'>
          <input data-element='inner' data-event='mouseover' data-phase='capture' type='checkbox'>
        </td>
        <td class='bubble'>
          <input data-element='inner' data-event='mouseover' data-phase='bubble' type='checkbox'>
        </td>
      </tr>
      <tr class='click control'>
        <td class='core'>core</td>
        <td>click</td>
        <td class='capture'>
          <input data-element='core' data-event='click' data-phase='capture' type='checkbox'>
        </td>
        <td class='bubble'>
          <input data-element='core' data-event='click' data-phase='bubble' type='checkbox'>
        </td>
      </tr>
      <tr class='control mouseover'>
        <td class='core'>core</td>
        <td>mouseover</td>
        <td class='capture'>
          <input data-element='core' data-event='mouseover' data-phase='capture' type='checkbox'>
        </td>
        <td class='bubble'>
          <input data-element='core' data-event='mouseover' data-phase='bubble' type='checkbox'>
        </td>
      </tr>
    </table>
    <!-- / FIXME only need build() -->
    <script>
      /*
       * build
       *
       * Convenience function for creating new DOM nodes.
       *
       **/
      
      function build(tag, options) {
        var element = document.createElement(tag),
            copy    = (k,v) => element[k] = v,
            recipes = {
              className:   copy,
              id:          copy,
              contains:    (k,v) => { v.forEach((c) => element.appendChild(c)) },
              text:        (k,v) => { element.textContent = v },
              class:       (k,v) => { element.className = v },
              textContent: copy,
              onclick:     copy
            };
      
        for (var k in recipes) {
          if(options[k]) { recipes[k](k, options[k]); }
        }
        return element;
      }
      
      
      /*
       * ajax
       *
       * Convenience function for dealing with asynchronous requests.
       *
       **/
      
      function ajax(url, data){
        var xhr = new XMLHttpRequest();
        xhr.onReadyStateChange = function() {
          if(xhr.readyState === XMLHttpRequest.DONE) {
            if(xhr.status === 200) {
              var response = JSON.parse(xhr.responseText);
              console.log(response);
            }
          }
        }
        xhr.open('POST', url, true);
        xhr.send(JSON.stringify(data));
      }
      
      
      /*
       * Slides
       *
       * Displays documents on the page.
       *
       * initialize() is called from the document to get things started.
       *
       **/
      
      var Slides = {
        slides: [],
        element: null,
      
        slideAttr: "data-slide-index",
      
        initialize() {
          this.slides = data["slides"];
          this.element = document.getElementById("slides");
          this.slides.forEach(this.buildSlide.bind(this));
        },
      
        buildSlide(slide, index) {
          if(slide.saved) {
            var section = Serializer.rebuild(slide.saved);
          } else {
            var section = build("section", {className: "code"});
            slide.code.split("\n").forEach(function(line) {
              section.innerHTML += '<p class="line">' + line + '</p>';
            });
          }
          section.setAttribute(this.slideAttr, index);
          this.element.appendChild(section);
        },
      
        /*
         * addWord
         *
         * Creates a tooltip listener for a given word/definition combo.
         * Optionally saves the definition to the server. (TODO not implemented yet)
         *
         **/
      
        addWord(elWord, definition, save=true) {
          // XXX decouple from TooltipManager
          TooltipManager.watch(elWord, definition);
          elWord.definition = definition;
          if(save) this.update(elWord);
        },
      
        update(elWord) {
          var elSlide = this.findSlide(elWord),
              index   = elSlide.getAttribute(this.slideAttr),
              slide   = this.slides[index];
          slide.saved = Serializer.save(elSlide);
          this.sync();
        },
      
        sync(data, index) {
          ajax("/save", this.slides);
        },
      
        findSlide(el) {
          if(el.hasAttribute(this.slideAttr)) return el;
          else return this.findSlide(el.parentNode);
        },
      
        appendControls(controls) {
          this.element.appendChild(controls);
        }
      };
      
      /*
       * Serializer
       *
       * Saves and loads slides into Plain Old JavaScript Objects.
       *
       **/
      
      var Serializer = {
        rebuild(saved, index) {
          if(saved.tag) var n = document.createElement(saved.tag);
          else if(saved.data) var n = document.createTextNode(saved.data);
          if(saved.class) n.className = saved.class;
          saved.children.forEach((c) => n.appendChild(this.rebuild(c)));
          if(saved.definition) Slides.addWord(n, saved.definition, false);
          return n;
        },
      
        save(node) {
          return {
            tag: node.tagName,
            class: node.className,
            definition: node.definition,
            data: node.data,
            children: node.childNodes.map((n) => this.save(n))
          };
        }
      };
      
      
      /*
       * Editor
       *
       * Enable live creation of new definition Words.
       *
       **/
      
      var Editor = {
        initialize() {
          this.buildControls();
          Slides.appendControls(this.defControls);
        },
      
        addDefinition(event) {
          var elWord = build("span", {className: "word"}),
              definition = this.defInput.value;
          NodeChirurgeon.wrapSelection(elWord, document.getSelection());
          Slides.addWord(elWord, definition);
          this.defInput.value = "";
        },
      
        buildControls() {
          this.defButton   = build("button", {
                               id: "add-definition",
                               textContent: "Define",
                               onclick: this.addDefinition.bind(this)
                             });
          this.defInput    = build("input", {
                               id: "write-definition"
                             });
          this.defControls = build("div", {
                               id: "definition-controls",
                               contains: [this.defInput, this.defButton]
                             });
        }
      };
      
      
      /*
       * TooltipManager
       *
       * Given an element and a definition, make a hover popup for the element.
       *
       * By passing true to Element.addEventListener(), we cause element to listen
       * in "capture" mode, which means the callback will be triggered as the event
       * descends down the hierarchy rather than on its way back up.
       *
       * console.log(generateMessage(data));  |  1  <- firstCaughtBy
       *             generateMessage(data)    |  2
       *                             data     V  3
       *
       * This allows us to generate tooltips in order "on the way down", without
       * ever having to keep track of the tooltips ourselves.
       *
       **/
      
      var TooltipManager = {
        element: null,
        active: null,
      
        initialize() {
          this.element = document.getElementById("tooltip");
        },
      
        watch(element, definition) {
          element.addEventListener("mouseover", (event) => {
            if(!event.firstCaughtBy) { event.firstCaughtBy = element; }
            this.push(element, definition, event.firstCaughtBy);
          }, true);
      
          element.addEventListener("mouseout", (event) => {
            this.pop(element);
          }, true);
        },
      
        push(element, definition, elOuter) {
          this.element.appendChild(
            this.build(
              AlignedWord.buildElement(element, elOuter),
              definition
            )
          );
          this.setActive(element);
        },
      
        pop(element) {
          this.element.removeChild(this.element.lastChild);
          this.setActive(null);
        },
      
        setActive(element) {
          if(this.active) { this.active.classList.remove("active"); }
          if(element) {
            this.active = element;
            element.classList.add("active");
          } else {
            this.active = null;
          }
        },
      
        build(elWord, definition) {
          return build("div", {
            className: "tooltip",
            contains: [
              build("div", {className: "word", contains: [elWord]}),
              build("div", {className: "definition", text: definition})
            ]
          })
        }
      };
      
      
      /*
       * AlignedWord
       *
       * Creates horizontally aligned nested Tooltips by reproducing their entire
       * node ancestry. For example:
       *
       * ACTUAL TOOLTIP CONTENTS:
       *
       * console.log(generateMessage(data));    <-- outer
       * console.log(generateMessage(data));
       * console.log(generateMessage(data));    <-- mouseover target
       *
       * Each Word gets its own element, and we use color: transparent to hide the
       * text of ancestors in the Tooltip for a given Word, so the Tooltips end up
       * looking like this:
       *
       * VISIBLE TOOLTIP CONTENTS:
       *
       * console.log(generateMessage(data));    <-- outer
       *             generateMessage(data)
       *                             data       <-- mouseover target
       **/
      
      var AlignedWord = {
        buildElement(target, outer) {
          return deepCopy(outer, function(copy, original) {
            if(original === target) {
              copy.className += " shown";
            }
          });
        }
      };
      
      function deepCopy(original, editClone) {
        // copy classes, IDs, but not child text or elements
        var copy = original.cloneNode();
        editClone(copy, original);
        original.childNodes.forEach(function(child) {
          copy.appendChild(deepCopy(child, editClone));
        });
        return copy;
      }
      
      
      /*
       * NodeChirurgeon
       *
       * Divide, extract, enclose, and transplant nodes with surgical accuracy.
       *
       * If you select a method call parameter within the text node of a <p> tag...
       *                  ___________
       * <p> "console.log(myAdminCred);" </p>
       *
       * Calling Chirurgeon.wrapSelection(<span></span>, selection) will produce:
       *
       * <p>
       *     "console.log("
       *     <span>
       *         "myAdminCred"
       *     </span>
       *     ");"
       * </p>
       *
       **/
      
      var NodeChirurgeon = {
        wrapSelection(wrapper, selection) {
          var [start, end] = Scalpel.makeBoundaryIncisions(selection);
          Suture.transplantNodes(wrapper, start, end);
        }
      };
      
      /*
       * Scalpel
       *
       * If a selection begins or ends in the middle of a text node (such as in the
       * example above), the node must be split at the selection boundaries so the
       * actual selected text can be moved to the wrapper.
       *
       **/
      
      var Scalpel = {
        makeBoundaryIncisions(selection) {
          var start = this.cut(selection.anchorNode, selection.anchorOffset),
              end   = this.cut(selection.focusNode, selection.focusOffset);
      
          // "anchor" and "focus" always correspond to "where the selection event
          // began" and "where the selection event ended", but we want to normalize
          // this to "left" and "right" so we can iterate sanely using nextSibling.
      
          if(this.userDraggedRightToLeft(start, end)) {
            return [end, start];
          } else {
            return [start, end];
          }
        },
      
        cut(node, cutIndex) {
          if(cutIndex > 0 && cutIndex < node.length) {
            // selected in the middle: Hello[, world!]
            return node.splitText(cutIndex);
          } else {
            // selected at a boundary: [Hello, world!]
            return node;
          }
        },
      
        userDraggedRightToLeft(a, b) {
          // http://stackoverflow.com/a/23512678/16034
          // XXX move this to Suture, which is the only code that actually
          // cares about the order
          return a.compareDocumentPosition(b) === Node.DOCUMENT_POSITION_PRECEDING;
        }
      };
      
      var Suture = {
        transplantNodes(newParent, start, end) {
          // Insert the new parent first, before we mess with the DOM.
          start.parentNode.insertBefore(newParent, start);
          // Transplant all siblings between start & end to the new parent.
          this.walkSiblings(start, end, (node) => newParent.appendChild(node));
        },
      
        walkSiblings(start, end, callback) {
          var cache, cursor = start;
          do {
            // cache the next sibling, since we're expecting to move
            // the cursor node around within the DOM hierarchy
            cache = cursor.nextSibling;
            callback(cursor);
            cursor = cache;
          } while (cursor != end);
        }
      };
    </script>
    <script>
      var controls = document.getElementById("controls");
      var logger = document.getElementById("logger");
      
      var colors = {
        // PLAIN RGB SCHEME
        // light
        lightRed: { red: 255, green: 170, blue: 170 },
        lightGreen: { red: 170, green: 255, blue: 170 },
        lightBlue: { red: 170, green: 170, blue: 255 },
        // heavy
        red: { red: 255, green: 0, blue: 0 },
        green: { red: 0, green: 255, blue: 0 },
        blue: { red: 0, green: 0, blue: 255 },
      
        // COLORBLIND-SAFE SCHEME
        // http://colorbrewer2.org/#type=qualitative&scheme=Dark2&n=3
        // light
        lightTeal: {red: 138, green: 234, blue: 205},
        lightPumpkin: { red: 240, green: 178, blue: 132},
        lightGrape: {red: 173, green: 169, blue: 222},
      
        // light
        teal: { red: 27, green: 158, blue: 119 },
        pumpkin: { red: 217, green: 95, blue: 2 },
        grape: { red: 117, green: 112, blue: 179 }
      };
      
      var ColorManager = {
        baseColors: {
          outer: colors.lightTeal,
          inner: colors.lightPumpkin,
          core: colors.lightGrape
        },
      
        focusColors: {
          outer: colors.teal,
          inner: colors.pumpkin,
          core: colors.grape
        },
      
        outer: null,
        inner: null,
        core: null,
      
        elements: [],
      
        animating: false,
        focused: null,
        clearFocusTimeout: null,
      
        pulseBaseTime: 10,
        focusBaseTime: 25,
        pulseTime: null,
        focusTime: null,
      
        maxSpeed: 50,
        speed: 25,
      
        pulseColor: {red: 255, green: 255, blue: 0},
      
        frameTime: 10,
      
        initialize: function() {
          this.outer = document.getElementById("outer");
          this.inner = document.getElementById("inner");
          this.core = document.getElementById("core");
      
          this.elements = [this.outer, this.inner, this.core];
      
          var styleSheet = document.styleSheets[0];
          styleSheet.insertRule("td.outer, table#logger tr td.outer { background: " + RGB.toString(this.baseColors.outer) + "; }", styleSheet.rules.length);
          styleSheet.insertRule("td.inner, table#logger tr td.inner { background: " + RGB.toString(this.baseColors.inner) + "; }", styleSheet.rules.length);
          styleSheet.insertRule("td.core, table#logger tr td.core { background: " + RGB.toString(this.baseColors.core) + "; }", styleSheet.rules.length);
      
          console.groupCollapsed("update: initialize");
          this.update();
          console.groupEnd();
      
          this.setSpeed(this.speed);
        },
      
        increaseSpeed: function() {
          this.setSpeed(this.speed + 1);
        },
      
        decreaseSpeed: function() {
          this.setSpeed(this.speed - 1);
        },
      
        setSpeed: function(value) {
          if(value > this.maxSpeed) return false;
          if(value < 1) return false;
          this.speed = value;
          this.pulseTime = this.pulseBaseTime * (this.maxSpeed - this.speed + 1);
          this.focusTime = this.focusBaseTime * (this.maxSpeed - this.speed + 1);
          document.querySelector("#meta .speed").textContent = this.speed + "/" + this.maxSpeed;
        },
      
        update: function(logFrame=console) {
          if(this.animating && !logFrame) {
            console.log("skipping arbitrary update() call during animation");
            return false;
          }
          this.elements.forEach((element) => {
            this.updateElement(element, logFrame);
          });
        },
      
        updateElement: function(element, logFrame) {
          var color;
      
          if(element.animating) color = element.interpolated;
          else color = this.getColor(element);
      
          this.setColor(element, color, logFrame);
      
          if(element.other) this.setColor(element.other, color, logFrame);
        },
      
        getColor: function(element) {
          if(this.focused === element) return this.focusColors[element.id];
          else return this.baseColors[element.id];
        },
      
        focus: function(element, other) {
          if(this.clearFocusTimeout) {
            clearTimeout(this.clearFocusTimeout);
            this.clearFocusTimeout = null;
          }
      
          this.focused = element;
          element.other = other;
          console.groupCollapsed("update: focus on " + element.id);
          this.update();
          console.groupEnd();
      
          return new Promise((resolve, reject) => {
            this.clearFocusTimeout = setTimeout(() => {
              this.clearFocus(element);
              resolve();
            }, this.focusTime);
          });
        },
      
        clearFocus: function(element) {
          this.focused = null;
          console.groupCollapsed("update: clear focus");
          this.update();
          element.other = null;
          console.groupEnd();
        },
      
        setColor: function(element, rgb, logger) {
          logger.log("setting", element.id, "to", rgb);
          element.style.backgroundColor = RGB.toString(rgb);
        },
      
        pulse: function(element) {
          this.animating = true;
          element.interpolated = this.getColor(element);
          element.animating = true;
      
          var callback = (scale, logFrame) => {
            var base = this.getColor(element);
            element.interpolated = Animation.getInterpolatedColor(base, this.pulseColor, scale);
            logFrame.log("animate " + element.id + " at scale " + scale);
            logFrame.log("update");
            this.update(logFrame);
          };
      
          var finished = () => {
            this.animating = false;
            element.animating = false;
            element.interpolated = null;
          };
      
          return Animation.animate(this.pulseTime, this.frameTime, callback, finished);
        }
      };
      
      var queueMode = false;
      var queuedEvents = [];
      
      var RGB = {
        // http://queueoverflow.com/questions/34980574/how-to-extract-color-values-from-rgb-string-in-javascript
        toObject: function(str){
          var match = str.match(/rgba?\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)?(?:, ?(\d(?:\.\d?))\))?/);
          return match ? {
            red: match[1],
            green: match[2],
            blue: match[3]
          } : {};
        },
      
        toString: function(data) {
          return "rgb(" + data.red + "," + data.green + "," + data.blue + ")";
        }
      };
      
      var Animation = {
        pulse: function(element) {
          var start = {red: 255, green: 255, blue: 0};
          var base = RGB.toObject(window.getComputedStyle(element).backgroundColor);
          element.animating = true;
      
          var callback = (scale, logFrame) => {
            var color = this.getInterpolatedColor(base, start, scale);
            ColorManager.setColor(element, color, logFrame);
          };
      
          var finished = (logAnim) => {
            element.animating = false;
          };
      
          return this.animate(ColorManager.pulseTime, 10, callback, finished);
        },
      
        getInterpolatedColor: function(base, start, scale) {
          var delta = {
            red: start.red - base.red,
            green: start.green - base.green,
            blue: start.blue - base.blue
          };
          return {
            red: Math.round(start.red - delta.red * scale),
            green: Math.round(start.green - delta.green * scale),
            blue: Math.round(start.blue - delta.blue * scale)
          };
        },
      
        animate: function(time, frameTime, callback, finished) {
          var frameCount = time / frameTime;
          var frame = 1;
      
          return new Promise((resolve, reject) => {
            var logAnim = new AsyncLogGroup("animation");
            var id = setInterval(() => {
              var scale = frame / frameCount;
      
              var logFrame = logAnim.open("animation frame " + frame);
              callback(scale, logFrame);
              logFrame.close();
      
              if(frame++ == frameCount) {
                clearInterval(id);
                finished(logAnim);
                logAnim.log("animation complete");
                logAnim.close();
                resolve();
              }
            }, frameTime);
          });
        }
      };
      
      function phaseToIcon(phase) {
        switch(phase) {
          case Event.NONE: return "X";
          case Event.CAPTURING_PHASE: return "⬇";
          case Event.AT_TARGET: return "◎";
          case Event.BUBBLING_PHASE: return "⬆";
        };
      }
      
      function phaseToWord(phase) {
        switch(phase) {
          case Event.NONE: return "none";
          case Event.CAPTURING_PHASE: return "capture";
          case Event.AT_TARGET: return "at target";
          case Event.BUBBLING_PHASE: return "bubble";
        };
      }
      
      function logEvent(event, phase) {
        var definedPhase = {
          "capture": "⬇",
          "bubble": "⬆"
        }[phase];
      
        var logged = build("tr", {
          class: "loggedEvent",
          contains: [
            build("td", { class: "phaseIcon", text: phaseToIcon(event.eventPhase) }),
            build("td", { class: "phaseName", text: phaseToWord(event.eventPhase) }),
            build("td", { class: "type", text: event.type }),
            build("td", {
              class: "currentTarget " + event.currentTarget.id,
              // so we can see which handler got it even when it's the target
              text: event.currentTarget.id + " " + definedPhase
            }),
            build("td", { class: "target " + event.target.id, text: event.target.id })
          ]
        });
        logger.appendChild(logged);
        return logged;
      }
      
      function clearEventLog() {
        var rows = logger.querySelectorAll("tr.loggedEvent");
        rows.forEach((tr) => logger.removeChild(tr));
        queuedEvents = [];
      }
      
      
      // otherwise we lose currentTarget, phase, etc.
      function cacheEvent(event) {
        return {
          currentTarget: event.currentTarget,
          target: event.target,
          eventPhase: event.eventPhase,
          elLog: event.elLog,
          type: event.type
        }
      }
      
      var nowPlaying = Promise.resolve();
      
      function catchEvent(event, phase) {
        var cached = cacheEvent(event);
        cached.elLog = logEvent(event, phase);
        queuedEvents.push(cached);
        if(!queueMode) {
          nowPlaying = nowPlaying.then(() => { return playEvent(cached) });
        }
      }
      
      function playEvents() {
        queuedEvents.forEach((e) => {
          nowPlaying = nowPlaying.then(() => { return playEvent(e) });
        });
      }
      
      function consoleLogPlayEvent(event) {
        var mainCSS = "color: blue; font-size: 14px;";
        var eventCSS = "color: black; font-size: 16px; font-weight: bold; font-family: monospace;";
        console.info("%c Playing %c%s%c Event", mainCSS, eventCSS, event.type, mainCSS);
      }
      
      function playEvent(event) {
        consoleLogPlayEvent(event);
        var logTarget = event.elLog.querySelector(".target");
        var logCurrent = event.elLog.querySelector(".currentTarget");
        return Promise.all([
          ColorManager.focus(event.currentTarget, logCurrent),
          ColorManager.pulse(event.target),
          Animation.pulse(logTarget)
        ]);
      }
      
      function toggleQueueMode() {
        if(queueMode) {
          document.querySelector("#meta .queueMode").textContent = "live";
          document.body.classList.remove("mode-queued");
          document.body.classList.add("mode-live");
          queueMode = false;
        } else {
          document.querySelector("#meta .queueMode").textContent = "queued";
          document.body.classList.remove("mode-live");
          document.body.classList.add("mode-queued");
          queueMode = true;
        }
      }
      
      function AsyncLogGroup(name, parentGroup=null) {
        this.name = name;
        this.messages = [];
        this.parentGroup = parentGroup;
      }
      
      AsyncLogGroup.LOG = 0;
      AsyncLogGroup.GROUP = 1;
      
      AsyncLogGroup.prototype.log = function() {
        this.messages.push({
          type: AsyncLogGroup.LOG,
          args: arguments
        });
      };
      
      AsyncLogGroup.prototype.open = function(name) {
        var group = new AsyncLogGroup(name, this);
        this.messages.push({
          type: AsyncLogGroup.GROUP,
          group: group
        });
        return group;
      };
      
      AsyncLogGroup.prototype.close = function() {
        if(this.parentGroup) return false;
        else this.print();
      };
      
      AsyncLogGroup.prototype.print = function() {
        console.groupCollapsed(this.name);
        this.messages.forEach((message) => {
          switch(message.type) {
          case AsyncLogGroup.LOG:
            console.log(...message.args);
            break;
          case AsyncLogGroup.GROUP:
            message.group.print();
            break;
          };
        });
        console.groupEnd();
      };
      
      //document.addEventListener("click", playEvents);
      document.addEventListener("keypress", function(event) {
        switch(event.key) {
        case 'c':
          clearEventLog();
          break;
        case 'q':
          toggleQueueMode();
          break;
        case 'p':
          playEvents();
          break;
        case '+':
          ColorManager.increaseSpeed();
          break;
        case '-':
          ColorManager.decreaseSpeed();
          break;
        }
      });
      
      controls.querySelectorAll("input").forEach((input) => {
        var phase = input.getAttribute("data-phase"),
            eventName = input.getAttribute("data-event"),
            elementID = input.getAttribute("data-element"),
            capture = (phase === "capture"),
            element = document.getElementById(elementID);
      
        if(eventName === "click" && phase === "capture") {
          input.checked = true;
        }
      
        element.addEventListener(eventName, (event) => {
          if(input.checked) {
            catchEvent(event, phase);
          }
        }, capture);
      });
      
      controls.querySelector("thead").addEventListener("click", (event) => {
        controls.classList.toggle("hidden");
      });
      
      ColorManager.initialize();
    </script>
  </body>
</html>
